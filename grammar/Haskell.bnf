{
  parserUtilClass="generated.HaskellParserUtil"

  elementTypeClass="org.jetbrains.haskell.parser.HaskellToken"
  tokenTypeClass  ="org.jetbrains.haskell.parser.HaskellElementType"

  tokens=[
    underscore = '_'             // Haskell keywords
    as = 'as'
    case = 'case'
    class = 'class'
    data = 'data'
    default = 'default'
    deriving = 'deriving'
    do = 'do'
    else = 'else'
    hiding = 'hiding'
    if = 'if'
    import = 'import'
    in = 'in'
    infix = 'infix'
    infixl = 'infixl'
    infixr = 'infixr'
    instance = 'instance'
    let = 'let'
    module_t = 'module'
    newtype = 'newtype'
    of = 'of'
    qualified = 'qualified'
    then = 'then'
    type = 'type'
    where = 'where'

    forall = 'forall'    // GHC extension keywords
    foreign = 'foreign'
    export = 'export'
    label = 'label'
    dynamic ='dynamic'
    safe = 'safe'
    interruptible = 'interruptible'
    unsafe = 'unsafe'
    mdo = 'mdo'
    family = 'family'
    role = 'role'
    stdcall = 'stdcall'
    ccall = 'ccall'
    capi = 'capi'
    prim = 'prim'
    javascript = 'javascript'
    proc = 'proc'                   // for arrow notation extension
    rec = 'rec'                    // for arrow notation extension
    group = 'group'                  // for list transform extension
    by = 'by'                     // for list transform extension
    using ='using'                  // for list transform extension
    pattern ='pattern'                // for pattern synonyms
    BLOCK_COMMENT = 'BLOCK_COMMENT'
    NEW_LINE = '\n'
/*
 '{-# INLINE'             { L _ (ITinline_prag _ _) }
 '{-# SPECIALISE'         { L _ ITspec_prag }
 '{-# SPECIALISE_INLINE'  { L _ (ITspec_inline_prag _) }
 '{-# SOURCE'                                   { L _ ITsource_prag }
 '{-# RULES'                                    { L _ ITrules_prag }
 '{-# CORE'                                     { L _ ITcore_prag }              -- hdaume: annotated core
 '{-# SCC'                { L _ ITscc_prag }
 '{-# GENERATED'          { L _ ITgenerated_prag }
 '{-# DEPRECATED'         { L _ ITdeprecated_prag }
 '{-# WARNING'            { L _ ITwarning_prag }
 '{-# UNPACK'             { L _ ITunpack_prag }
 '{-# NOUNPACK'           { L _ ITnounpack_prag }
 '{-# ANN'                { L _ ITann_prag }
 '{-# VECTORISE'          { L _ ITvect_prag }
 '{-# VECTORISE_SCALAR'   { L _ ITvect_scalar_prag }
 '{-# NOVECTORISE'        { L _ ITnovect_prag }
 '{-# MINIMAL'            { L _ ITminimal_prag }
 '{-# CTYPE'              { L _ ITctype }
 '{-# OVERLAPPING'        { L _ IToverlapping_prag }
 '{-# OVERLAPPABLE'       { L _ IToverlappable_prag }
 '{-# OVERLAPS'           { L _ IToverlaps_prag }
 '{-# INCOHERENT'         { L _ ITincoherent_prag }
 '#-}'                                          { L _ ITclose_prag }

*/
 dotdot = '..'                      // reserved symbols
 colon = ':'
 dcolon = '::'
 equal =  '='
 lam = '\\'
/*
 'lcase'        { L _ ITlcase }
 '|'            { L _ ITvbar }
 '<-'           { L _ ITlarrow }
 '->'           { L _ ITrarrow }
 '@'            { L _ ITat }
 '~'            { L _ ITtilde }
 '~#'           { L _ ITtildehsh }
 '=>'           { L _ ITdarrow }
 '-'            { L _ ITminus }
 '!'            { L _ ITbang }
 '*'            { L _ ITstar }
 '-<'           { L _ ITlarrowtail }            -- for arrow notation
 '>-'           { L _ ITrarrowtail }            -- for arrow notation
 '-<<'          { L _ ITLarrowtail }            -- for arrow notation
 '>>-'          { L _ ITRarrowtail }            -- for arrow notation
 */
 dot = '.'
 ocurly = '{'
 ccurly = '}'
 vocurly = 'vocurly'
 vccurly = 'vccurly'
 vsemicolon = 'vsemicolon'
 /*
 '['            { L _ ITobrack }
 ']'            { L _ ITcbrack }
 '[:'           { L _ ITopabrack }
 ':]'           { L _ ITcpabrack }
 '('            { L _ IToparen }
 ')'            { L _ ITcparen }
 '(#'           { L _ IToubxparen }
 '#)'           { L _ ITcubxparen }
 '(|'           { L _ IToparenbar }
 '|)'           { L _ ITcparenbar }
 ';'            { L _ ITsemi }
 ','            { L _ ITcomma }
 '`'            { L _ ITbackquote }
 SIMPLEQUOTE    { L _ ITsimpleQuote      }     -- 'x
*/
 VARID = 'VARID'
 CONID = 'CONID'
/*
 VARSYM         { L _ (ITvarsym   _) }
 CONSYM         { L _ (ITconsym   _) }
 QVARID         { L _ (ITqvarid   _) }
 QCONID         { L _ (ITqconid   _) }
 QVARSYM        { L _ (ITqvarsym  _) }
 QCONSYM        { L _ (ITqconsym  _) }
 PREFIXQVARSYM  { L _ (ITprefixqvarsym  _) }
 PREFIXQCONSYM  { L _ (ITprefixqconsym  _) }

 IPDUPVARID     { L _ (ITdupipvarid   _) }              -- GHC extension
*/
 CHAR = 'char'
 STRING = 'string'
/*
 INTEGER        { L _ (ITinteger  _) }
 RATIONAL       { L _ (ITrational _) }

 PRIMCHAR       { L _ (ITprimchar   _) }
 PRIMSTRING     { L _ (ITprimstring _) }
 PRIMINTEGER    { L _ (ITprimint    _) }
 PRIMWORD       { L _ (ITprimword  _) }
 PRIMFLOAT      { L _ (ITprimfloat  _) }
 PRIMDOUBLE     { L _ (ITprimdouble _) }

 DOCNEXT        { L _ (ITdocCommentNext _) }
 DOCPREV        { L _ (ITdocCommentPrev _) }
 DOCNAMED       { L _ (ITdocCommentNamed _) }
 DOCSECTION     { L _ (ITdocSection _ _) }

-- Template Haskell
'[|'            { L _ ITopenExpQuote  }
'[p|'           { L _ ITopenPatQuote  }
'[t|'           { L _ ITopenTypQuote  }
'[d|'           { L _ ITopenDecQuote  }
'|]'            { L _ ITcloseQuote    }
'[||'           { L _ ITopenTExpQuote   }
'||]'           { L _ ITcloseTExpQuote  }
TH_ID_SPLICE    { L _ (ITidEscape _)  }     -- $x
'$('            { L _ ITparenEscape   }     -- $( exp )
TH_ID_TY_SPLICE { L _ (ITidTyEscape _)  }   -- $$x
'$$('           { L _ ITparenTyEscape   }   -- $$( exp )
TH_TY_QUOTE     { L _ ITtyQuote       }      -- ''T
TH_QUASIQUOTE   { L _ (ITquasiQuote _) }
TH_QQUASIQUOTE  { L _ (ITqQuasiQuote _) }
*/
  ]
}

root ::= module

QCONID ::= (CONID '.')* CONID

modid   ::=
          CONID
        | QCONID

module ::= 'module' modid 'where' body

body ::= rest

rest ::= any*

any ::= !<<eof>>